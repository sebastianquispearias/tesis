{
    "sourceFile": "inferencia.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1750176946010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750181882066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,30 +1,123 @@\n+#!/usr/bin/env python3\r\n+# -*- coding: utf-8 -*-\r\n+\"\"\"\r\n+Script de inferencia para el modelo de segmentación de corrosión.\r\n+Permite cargar pesos entrenados, procesar una imagen, calcular IoU opcionalmente y visualizar resultados.\r\n+\"\"\"\r\n+import argparse\r\n+from pathlib import Path\r\n+\r\n import cv2\r\n import numpy as np\r\n import tensorflow as tf\r\n import matplotlib.pyplot as plt\r\n+import segmentation_models as sm\r\n \r\n-# 1) Carga modelo y pesos\r\n-model = build_model()  # o como lo definas en models.py\r\n-model.load_weights('checkpoints/best_C75.h5')\r\n+from models import build_model\r\n \r\n-# 2) Carga una imagen de test y su máscara\r\n-img = cv2.imread('data/all_results/regimes/C75/test/images/vt_test_6.png')\r\n-gt = cv2.imread('data/all_results/regimes/C75/test/masks/vt_test_6.png', 0) > 0\r\n \r\n-# 3) Preprocesa y predice\r\n-inp = preprocess(img)                # según tu pipeline\r\n-p = model.predict(np.expand_dims(inp,0))[0,...,0]\r\n-pred_mask = p > 0.5                  # tú eliges el umbral\r\n+def parse_args():\r\n+    p = argparse.ArgumentParser(\r\n+        description='Inferencia de segmentación de corrosión'\r\n+    )\r\n+    p.add_argument('--arch',\r\n+                   choices=['baseline', 'pspnet', 'fpn', 'deeplabv3+'],\r\n+                   default='baseline',\r\n+                   help='Arquitectura del modelo')\r\n+    p.add_argument('--backbone',\r\n+                   default='efficientnetb3',\r\n+                   help='Backbone para la arquitectura')\r\n+    p.add_argument('--weights',\r\n+                   required=True,\r\n+                   help='Ruta al archivo de pesos (.h5)')\r\n+    p.add_argument('--input',\r\n+                   required=True,\r\n+                   help='Imagen de entrada para inferencia')\r\n+    p.add_argument('--mask',\r\n+                   help='Máscara de ground truth para calcular IoU (opcional)')\r\n+    p.add_argument('--threshold',\r\n+                   type=float,\r\n+                   default=0.5,\r\n+                   help='Umbral para binarizar la predicción')\r\n+    p.add_argument('--no-show',\r\n+                   action='store_true',\r\n+                   help='No mostrar la visualización')\r\n+    return p.parse_args()\r\n \r\n-# 4) Calcula IoU  \r\n-intersection = np.logical_and(gt, pred_mask).sum()\r\n-union        = np.logical_or (gt, pred_mask).sum()\r\n-iou          = intersection / union\r\n-print(f\"IoU de esta inferencia: {iou:.3f}\")\r\n \r\n-# 5) Visualización\r\n-plt.figure(figsize=(12,4))\r\n-plt.subplot(1,3,1); plt.imshow(img[...,::-1]); plt.title('Imagen')\r\n-plt.subplot(1,3,2); plt.imshow(gt, cmap='gray');   plt.title('Ground Truth')\r\n-plt.subplot(1,3,3); plt.imshow(pred_mask, cmap='gray'); plt.title('Predicción')\r\n-plt.show()\r\n+def main():\r\n+    args = parse_args()\r\n+\r\n+    # Parámetros fijos según tus experimentos\r\n+    CLASSES     = ['corrosion']\r\n+    LR          = 1e-4\r\n+    INPUT_SHAPE = (384, 384, 3)\r\n+    n_classes   = 1 if len(CLASSES) == 1 else len(CLASSES) + 1\r\n+    activation  = 'sigmoid' if n_classes == 1 else 'softmax'\r\n+\r\n+    # 1) Construir y cargar modelo\r\n+    model = build_model(\r\n+        args.arch,\r\n+        args.backbone,\r\n+        n_classes,\r\n+        activation,\r\n+        LR,\r\n+        input_shape=INPUT_SHAPE\r\n+    )\r\n+    model.load_weights(args.weights)\r\n+    print(f\"[INFO] Pesos cargados desde: {args.weights}\")\r\n+\r\n+    # 2) Preprocesar imagen de entrada\r\n+    img_bgr = cv2.imread(args.input)\r\n+    if img_bgr is None:\r\n+        raise FileNotFoundError(f\"No se encontró la imagen: {args.input}\")\r\n+    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)\r\n+    img_resized = cv2.resize(img_rgb, INPUT_SHAPE[:2], interpolation=cv2.INTER_LINEAR)\r\n+    preprocess_fn = sm.get_preprocessing(args.backbone)\r\n+    inp = preprocess_fn(img_resized)\r\n+\r\n+    # 3) Inferencia\r\n+    pred = model.predict(np.expand_dims(inp, 0))[0]\r\n+    pred_mask = (pred[..., 0] > args.threshold)\r\n+    print(f\"[INFO] Predicción realizada con umbral {args.threshold}\")\r\n+\r\n+    # 4) Calcular IoU si hay máscara de referencia\r\n+    if args.mask:\r\n+        gt_bgr = cv2.imread(args.mask, cv2.IMREAD_GRAYSCALE)\r\n+        if gt_bgr is None:\r\n+            raise FileNotFoundError(f\"No se encontró la máscara: {args.mask}\")\r\n+        gt_mask = gt_bgr > 0\r\n+        intersection = np.logical_and(gt_mask, pred_mask).sum()\r\n+        union = np.logical_or(gt_mask, pred_mask).sum()\r\n+        iou = intersection / union if union > 0 else 0.0\r\n+        print(f\"[RESULT] IoU: {iou:.3f}\")\r\n+\r\n+    # 5) Visualización\r\n+    if not args.no_show:\r\n+        plt.figure(figsize=(12, 4))\r\n+        plt.subplot(1, 3, 1)\r\n+        plt.imshow(img_rgb)\r\n+        plt.title('Imagen de entrada')\r\n+        plt.axis('off')\r\n+\r\n+        if args.mask:\r\n+            plt.subplot(1, 3, 2)\r\n+            plt.imshow(gt_mask, cmap='gray')\r\n+            plt.title('Ground Truth')\r\n+            plt.axis('off')\r\n+\r\n+            plt.subplot(1, 3, 3)\r\n+            plt.imshow(pred_mask, cmap='gray')\r\n+            plt.title('Predicción')\r\n+            plt.axis('off')\r\n+        else:\r\n+            plt.imshow(pred_mask, cmap='gray')\r\n+            plt.title('Predicción')\r\n+            plt.axis('off')\r\n+\r\n+        plt.tight_layout()\r\n+        plt.show()\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                }
            ],
            "date": 1750176946010,
            "name": "Commit-0",
            "content": "import cv2\r\nimport numpy as np\r\nimport tensorflow as tf\r\nimport matplotlib.pyplot as plt\r\n\r\n# 1) Carga modelo y pesos\r\nmodel = build_model()  # o como lo definas en models.py\r\nmodel.load_weights('checkpoints/best_C75.h5')\r\n\r\n# 2) Carga una imagen de test y su máscara\r\nimg = cv2.imread('data/all_results/regimes/C75/test/images/vt_test_6.png')\r\ngt = cv2.imread('data/all_results/regimes/C75/test/masks/vt_test_6.png', 0) > 0\r\n\r\n# 3) Preprocesa y predice\r\ninp = preprocess(img)                # según tu pipeline\r\np = model.predict(np.expand_dims(inp,0))[0,...,0]\r\npred_mask = p > 0.5                  # tú eliges el umbral\r\n\r\n# 4) Calcula IoU  \r\nintersection = np.logical_and(gt, pred_mask).sum()\r\nunion        = np.logical_or (gt, pred_mask).sum()\r\niou          = intersection / union\r\nprint(f\"IoU de esta inferencia: {iou:.3f}\")\r\n\r\n# 5) Visualización\r\nplt.figure(figsize=(12,4))\r\nplt.subplot(1,3,1); plt.imshow(img[...,::-1]); plt.title('Imagen')\r\nplt.subplot(1,3,2); plt.imshow(gt, cmap='gray');   plt.title('Ground Truth')\r\nplt.subplot(1,3,3); plt.imshow(pred_mask, cmap='gray'); plt.title('Predicción')\r\nplt.show()\r\n"
        }
    ]
}