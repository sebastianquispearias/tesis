{
    "sourceFile": "inferencia_pytorch.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1750641398168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1750641398168,
            "name": "Commit-0",
            "content": "import os\r\nos.environ[\"KMP_DUPLICATE_LIB_OK\"]=\"TRUE\" # Para evitar el error de OpenMP en Windows\r\n\r\nimport argparse\r\nimport cv2\r\nimport numpy as np\r\nimport torch\r\nimport albumentations as A\r\nfrom albumentations.pytorch import ToTensorV2\r\nimport segmentation_models_pytorch as smp\r\nimport matplotlib.pyplot as plt\r\n\r\n# --- PARÁMETROS GLOBALES (deben coincidir con el entrenamiento) ---\r\nDEVICE = \"cuda\" if torch.cuda.is_available() else \"cpu\"\r\nBACKBONE = 'efficientnet-b3'\r\nINPUT_SHAPE = (384, 384)\r\nN_CLASSES = 1\r\n\r\n# --- TRANSFORMACIÓN PARA PREPROCESAR LA IMAGEN ---\r\npreprocess_transform = A.Compose([\r\n    A.Resize(*INPUT_SHAPE),\r\n    A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\r\n    ToTensorV2(),\r\n])\r\n\r\ndef parse_args():\r\n    p = argparse.ArgumentParser(description='Inferencia de Segmentación de Corrosión con PyTorch')\r\n    p.add_argument('--weights', required=True, help='Ruta al archivo de pesos del modelo (.pth)')\r\n    p.add_argument('--input', required=True, help='Ruta a la imagen de entrada para inferencia')\r\n    p.add_argument('--mask', help='(Opcional) Ruta a la máscara de ground truth para calcular IoU')\r\n    p.add_argument('--threshold', type=float, default=0.5, help='Umbral para binarizar la predicción')\r\n    p.add_argument('--no-show', action='store_true', help='Opción para no mostrar la visualización de Matplotlib')\r\n    return p.parse_args()\r\n\r\n\r\ndef main():\r\n    args = parse_args()\r\n\r\n    # --- 1. CONSTRUIR Y CARGAR MODELO ---\r\n    print(f\"INFO: Usando dispositivo: {DEVICE}\")\r\n    print(f\"INFO: Construyendo modelo DeepLabV3+ con backbone {BACKBONE}...\")\r\n    \r\n    model = smp.DeepLabV3Plus(\r\n        encoder_name=BACKBONE,\r\n        encoder_weights=None, # Los pesos se cargan desde el archivo, no de ImageNet\r\n        in_channels=3,\r\n        classes=N_CLASSES\r\n    ).to(DEVICE)\r\n\r\n    # Cargar los pesos entrenados\r\n    try:\r\n        model.load_state_dict(torch.load(args.weights, map_location=DEVICE))\r\n        print(f\"INFO: Pesos cargados exitosamente desde: {args.weights}\")\r\n    except FileNotFoundError:\r\n        print(f\"ERROR: No se encontró el archivo de pesos en: {args.weights}\")\r\n        return\r\n        \r\n    model.eval() # Poner el modelo en modo de evaluación\r\n\r\n    # --- 2. CARGAR Y PREPROCESAR IMAGEN DE ENTRADA ---\r\n    try:\r\n        img_bgr = cv2.imread(args.input)\r\n        if img_bgr is None: raise FileNotFoundError\r\n        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)\r\n    except FileNotFoundError:\r\n        print(f\"ERROR: No se encontró la imagen de entrada en: {args.input}\")\r\n        return\r\n\r\n    # Aplicar transformaciones\r\n    transformed = preprocess_transform(image=img_rgb)\r\n    input_tensor = transformed['image'].unsqueeze(0).to(DEVICE) # Añadir dimensión de batch\r\n\r\n    # --- 3. REALIZAR INFERENCIA ---\r\n    print(\"INFO: Realizando inferencia...\")\r\n    with torch.no_grad():\r\n        pred_logits = model(input_tensor)\r\n        pred_probs = torch.sigmoid(pred_logits)\r\n\r\n    # Procesar la salida: quitar dimensión de batch, mover a CPU, binarizar\r\n    pred_mask = (pred_probs.squeeze().cpu().numpy() > args.threshold).astype(np.uint8)\r\n    print(f\"INFO: Predicción realizada con umbral de {args.threshold}\")\r\n\r\n    # --- 4. CALCULAR IoU (SI SE PROPORCIONA MÁSCARA) ---\r\n    iou = None\r\n    if args.mask:\r\n        try:\r\n            gt_bgr = cv2.imread(args.mask, cv2.IMREAD_GRAYSCALE)\r\n            if gt_bgr is None: raise FileNotFoundError\r\n            # Redimensionar ground truth para que coincida con el tamaño de la predicción\r\n            gt_resized = cv2.resize(gt_bgr, (pred_mask.shape[1], pred_mask.shape[0]), interpolation=cv2.INTER_NEAREST)\r\n            gt_mask = (gt_resized > 0)\r\n            \r\n            intersection = np.logical_and(gt_mask, pred_mask).sum()\r\n            union = np.logical_or(gt_mask, pred_mask).sum()\r\n            iou = intersection / union if union > 0 else 0.0\r\n            print(f\"INFO: IoU calculado: {iou:.4f}\")\r\n        except FileNotFoundError:\r\n            print(f\"ADVERTENCIA: No se encontró la máscara en: {args.mask}. No se calculará el IoU.\")\r\n\r\n    # --- 5. VISUALIZACIÓN ---\r\n    if not args.no_show:\r\n        print(\"INFO: Mostrando resultados...\")\r\n        \r\n        # Redimensionar la predicción al tamaño original de la imagen para una mejor visualización\r\n        pred_mask_original_size = cv2.resize(pred_mask, (img_rgb.shape[1], img_rgb.shape[0]), interpolation=cv2.INTER_NEAREST)\r\n        \r\n        num_plots = 1\r\n        if args.mask: num_plots = 3\r\n        \r\n        plt.figure(figsize=(15, 5))\r\n\r\n        # Plot 1: Imagen Original\r\n        plt.subplot(1, num_plots, 1)\r\n        plt.imshow(img_rgb)\r\n        plt.title('Imagen de Entrada')\r\n        plt.axis('off')\r\n\r\n        if args.mask:\r\n            # Plot 2: Ground Truth\r\n            plt.subplot(1, num_plots, 2)\r\n            plt.imshow(gt_mask, cmap='gray')\r\n            plt.title('Ground Truth')\r\n            plt.axis('off')\r\n\r\n            # Plot 3: Predicción\r\n            plt.subplot(1, num_plots, 3)\r\n            plt.imshow(pred_mask_original_size, cmap='gray')\r\n            plt.title(f'Predicción (IoU: {iou:.4f})' if iou is not None else 'Predicción')\r\n            plt.axis('off')\r\n        else:\r\n            # Si no hay máscara, mostrar la predicción en el segundo subplot\r\n            plt.subplot(1, 2, 2)\r\n            plt.imshow(pred_mask_original_size, cmap='gray')\r\n            plt.title('Predicción')\r\n            plt.axis('off')\r\n\r\n        plt.tight_layout()\r\n        plt.show()\r\n\r\nif __name__ == '__main__':\r\n    main()"
        }
    ]
}