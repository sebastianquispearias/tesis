{
    "sourceFile": "compute_kernel_stats.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1750038355382,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750609517099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,25 +1,89 @@\n-# compute_kernel_stats.py\r\n-import json\r\n-import glob\r\n+import sys\r\n import cv2\r\n import numpy as np\r\n-from scipy.ndimage import distance_transform_edt\r\n+import pandas as pd\r\n+from skimage.measure import label, regionprops_table\r\n \r\n-def main():\r\n-    radii = []\r\n-    # Usamos las máscaras rotuladas para medir pitting real\r\n-    for mask_path in glob.glob('data/all_results/regimes/C75/train/masks_labeled/*.png'):\r\n-        mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE) > 0\r\n-        dt   = distance_transform_edt(mask)\r\n-        # Para cada isla, tomo el mayor distance transform como radio\r\n-        if np.any(mask):\r\n-            radii.append(dt[mask].max())\r\n-    # Calculo percentiles y redondeo a entero\r\n-    p25, p50, p75 = np.percentile(radii, [25,50,75]).round().astype(int)\r\n-    stats = {\"radii\": [int(p25), int(p50), int(p75)]}\r\n-    with open('data/kernel_stats.json','w') as f:\r\n-        json.dump(stats, f)\r\n-    print(\"Kernel radii saved:\", stats)\r\n+def analizar_mascaras(directorio_mascaras):\r\n+    \"\"\"\r\n+    Analiza todas las máscaras en un directorio para extraer estadísticas\r\n+    de forma de los defectos.\r\n+    \"\"\"\r\n+    # Usamos glob para encontrar todas las imágenes .png\r\n+    from glob import glob\r\n+    rutas_mascaras = glob(f\"{directorio_mascaras}/*.png\")\r\n \r\n-if __name__ == \"__main__\":\r\n-    main()\r\n+    if not rutas_mascaras:\r\n+        print(f\"Error: No se encontraron máscaras en '{directorio_mascaras}'\")\r\n+        return\r\n+\r\n+    print(f\"Analizando {len(rutas_mascaras)} máscaras...\")\r\n+\r\n+    all_props = []\r\n+    for ruta in rutas_mascaras:\r\n+        # Cargar la máscara y binarizar\r\n+        mask = cv2.imread(ruta, cv2.IMREAD_GRAYSCALE)\r\n+        if mask is None:\r\n+            continue\r\n+        \r\n+        # Binarizar la máscara (asumimos que el defecto es cualquier cosa > 0)\r\n+        mask_binaria = (mask > 0).astype(np.uint8)\r\n+\r\n+        # Etiquetar regiones conectadas (cada mancha de defecto)\r\n+        mascara_etiquetada = label(mask_binaria)\r\n+\r\n+        # Extraer propiedades de cada región\r\n+        # Solo calculamos para máscaras que no están completamente vacías\r\n+        if mascara_etiquetada.max() > 0:\r\n+            props = regionprops_table(\r\n+                mascara_etiquetada,\r\n+                properties=('area', 'equivalent_diameter', \r\n+                            'major_axis_length', 'minor_axis_length', 'orientation')\r\n+            )\r\n+            all_props.append(pd.DataFrame(props))\r\n+\r\n+    if not all_props:\r\n+        print(\"No se encontraron defectos en ninguna de las máscaras analizadas.\")\r\n+        return\r\n+\r\n+    # Combinar todas las propiedades en un único DataFrame\r\n+    df = pd.concat(all_props, ignore_index=True)\r\n+\r\n+    # Calcular el ratio de aspecto (elongación)\r\n+    # Añadimos un valor pequeño para evitar división por cero si un defecto es una línea perfecta\r\n+    df['aspect_ratio'] = df['major_axis_length'] / (df['minor_axis_length'] + 1e-6)\r\n+\r\n+    # Convertir orientación de radianes a grados\r\n+    df['orientation_deg'] = np.rad2deg(df['orientation'])\r\n+\r\n+    # --- Resultados ---\r\n+    print(\"\\n--- ANÁLISIS ESTADÍSTICO DE FORMAS DE DEFECTOS ---\\n\")\r\n+\r\n+    # 1. Análisis de TAMAÑO (en píxeles)\r\n+    print(\"1. Distribución de Tamaño (Diámetro Equivalente):\")\r\n+    p25, p50, p75 = np.percentile(df['equivalent_diameter'], [25, 50, 75])\r\n+    print(f\"   - Percentil 25 (P25): {p25:.2f} px\")\r\n+    print(f\"   - Mediana (P50):      {p50:.2f} px\")\r\n+    print(f\"   - Percentil 75 (P75): {p75:.2f} px\\n\")\r\n+\r\n+    # 2. Análisis de FORMA (Elongación)\r\n+    print(\"2. Distribución de Forma (Ratio de Aspecto):\")\r\n+    mediana_ar = df['aspect_ratio'].median()\r\n+    print(f\"   - Mediana del Ratio de Aspecto: {mediana_ar:.2f}\")\r\n+    print(\"     (Un valor de 1.0 es un círculo perfecto. Valores > 1 son elípticos/alargados)\\n\")\r\n+\r\n+    # 3. Análisis de ORIENTACIÓN (en grados)\r\n+    print(\"3. Distribución de Orientación:\")\r\n+    # Histograma para ver la distribución de ángulos\r\n+    hist, bin_edges = np.histogram(df['orientation_deg'], bins=12, range=(-90, 90))\r\n+    print(\"   - Histograma de Orientaciones (de -90° a 90°):\")\r\n+    for i in range(len(hist)):\r\n+        print(f\"     - Rango {bin_edges[i]:.0f}° a {bin_edges[i+1]:.0f}°: {hist[i]} defectos\")\r\n+\r\n+if __name__ == '__main__':\r\n+    if len(sys.argv) != 2:\r\n+        print(\"Uso: python analizar_morfologia_mascaras.py <ruta_al_directorio_de_mascaras>\")\r\n+        sys.exit(1)\r\n+    \r\n+    directorio = sys.argv[1]\r\n+    analizar_mascaras(directorio)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1750038355382,
            "name": "Commit-0",
            "content": "# compute_kernel_stats.py\r\nimport json\r\nimport glob\r\nimport cv2\r\nimport numpy as np\r\nfrom scipy.ndimage import distance_transform_edt\r\n\r\ndef main():\r\n    radii = []\r\n    # Usamos las máscaras rotuladas para medir pitting real\r\n    for mask_path in glob.glob('data/all_results/regimes/C75/train/masks_labeled/*.png'):\r\n        mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE) > 0\r\n        dt   = distance_transform_edt(mask)\r\n        # Para cada isla, tomo el mayor distance transform como radio\r\n        if np.any(mask):\r\n            radii.append(dt[mask].max())\r\n    # Calculo percentiles y redondeo a entero\r\n    p25, p50, p75 = np.percentile(radii, [25,50,75]).round().astype(int)\r\n    stats = {\"radii\": [int(p25), int(p50), int(p75)]}\r\n    with open('data/kernel_stats.json','w') as f:\r\n        json.dump(stats, f)\r\n    print(\"Kernel radii saved:\", stats)\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"
        }
    ]
}